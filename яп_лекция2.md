**Кортеж** - совокупность данных, которая может содержать любое количество элементов разных типов
```fsharp
let divRem a b =
    (a,b)
```

#   Область действия имен

**Тело функции может содержать определения индефикаторов** - локальных имен значений и функций.

1.  В  F# можно объъявить новую функцию в теле другой функции, т.е. функции могут быть вложенными
2. Область действия идентификатора - тело функции, в которой он объявлен
3. Вложенные функции имеет доступ к любым значениям, объявленным в объемлещюей функции.

*Именно отступ указывает на то, что определение идентификатора находится внутри тела функции*


## Пример

```fsharp
let defineMessage1 () = 
    let message = "Visual Studio C#"
    printfn "%s" message
    let defineMessage2() = 
        let defineMessage3() = 
            let message3 = "Visual Studio F#"
            printfn "%s" message3
        let message2 = "Visual Studio J#"
        printfn "%s" message2
        defineMessage3()
    defineMessage2();;
```

```
> defineMessage1();;
Visual Studio C#
Visual Studio J#
Visual Studio F#
```

## Пример
```fsharp
let f() = 
    let g () = 
        let x = 10
        printfn " g_result = %i" (20 + x)
    g()
    printfn "f_result = %i" (20 + x)
```

`> f();;`<br>
`printfn "f_result = %i" (20 + x) error`

```fsharp
let f() = 
    let x = 5
    let g() = 
        let x = 10
        printfn "g_result = %i" (20 + x)
    g()
    printfn "f_result = %i" (20 + x)
```
```
f();;
g_result = 30
f_result = 25z
```

# Условные выражения

__Синтаксис условного выражения__

`if <логическое выражение> then <выражение_1> [else <выражение_2>]`

> Условное выражение возвращает значение

> Типы значений **выражения_1** и **выражения_2** должны совпадаеть

> Если ветвь `else` отсутствует, то **выражение_2** имеет тип `union`

## Пример

```fsharp
let isEven x = 
    let result =
        if x % 2 = 0 then "число четное"
            else "число нечетное"
```


## Пример

```fsharp
let myday day =
    if day = "понедельник" then printfn "понедельник"
        elif day = "вторник" then printfn "вторник"
            elif day = "среда" then prinfn "среда"
                else prinfn "четверг"
```

# Рекурсивыне функици

> В ИП циклы основны на *изменении некоторого значения* (в параметре цикла или условия окончания)

В ФП значения являются **неизменяемыми**

> *При реализации рекурсии*: **вызываемая** функция должна решать более **простую** задачу, чем **вызывающая**, иначе рекурсия никогда не закончиться

* Функция должна **вызывать сама себя** для решения более **простых** задач

## Пример

```fsharp
let rec sum n = 
    if n = 1 then 1
        else n + sum (n - 1)
```

|аргумент n|значение функции sum n|
|-|-|
|5|
|4|
|3|
|2|
|1|

## Пример. Факториал

```fsharp
let rec fact n = 
    if n = 0 then 1
        else n * fact(n - 1)
```

## Пример. Все числа между двумя заданными

```fsharp
let rec printx_y x y = 
    if x >= y then printfn "%d" x
        else prinftn "%d" x
        printx_y (x + 1) y
```

# Каррирование

> **Каррирование** - это возможность функции принимать аргументы по одном, каждый раз возвращая новую функцию от меньшего числа аргументов

## Пример. Сложение двух чисел

`> let add x y = x + y;;`
`val add : int -> int -> int`

Каррируем (фиксируем) первый параметр функции и, таким образом создаем функцию, принимающую второй параметр:

`> let addFive = add 5;;`
`val addFive : (int -> int)`

> `addFive` - каррированная функциия

`> let result - addFive 10;;` вызов каррированной функции<br>
`val result : int = 15`

> Карринг объясняет наличие стрелки в типе функции между ее аргументрами:

`> let add1 (x:float) (y:float) = x + y` <br>

## Прмиер. Вывод целых чисел

```fsharp
> let x = 3;;
val x : int = 3
> let y = 10;;
val y : int = 10
> let print_int = printfn "%d";;
val print_int : (int -> unit)
> print_int x;;
3
val it : unit = ()
> print_int y;;
10
val it : unit = ()
```

## Пример. Вывод вещественных чисел

```fsharp 
> let sq x = x*x;;
val sq : int -> int
> printfloat = printfn "\n %5.2f";;
val printfloat : (float -> unit)
> printfloat (float 5);;
5.00
val it : unit = ()
```

# Частично применимые функции

Частичное примененеи дает возможность
* **зафиксировать** значение **нескольких** аргументов функции
* **создать** новую функцию **с меньшим** числом аргументов

## Пример. Частичное примене

```fsharp
> let add x y z = x + y + z;;
val add : int -> int -> int -> int
> let addf = add 4 5;;;
val addf: (int -> int)
> addf 2;;
val it : int = 11
```

# Рекурсия и каррирование

## Пример.

```fsharp
> let rec mypow n x =
    if n = 0 then 1.0
        else x * mypow (n - 1) x;;
val mypow : int -> float -> float
> let square = mypow 2;;
val square : (float -> float)
> square 5.0;;
val it : float = 25.0
> let five = mypow 5;;
val five : (float -> float)
> five 3.0;;
val it : float = 243.0
```

# Кортежи

> **Кортежи** - совокупность данных, которая может содержать **любое** количество элементов **любых** типов.

> При записи типа кортежа используется символ `*`

## Пример

```fsharp
> let x = (1,2,"aaa","fff",1.2);;
```

```fsharp
> let d (x1,y1) (x2,y2) = sqrt ((x2 - x1))**2.0 + (y2 - y1)**2.0
> d (1.0, 1.0) (2.0, 2.0);;
```

# Операции над кортежами

1. Извлечение элементов их двухэлементного кортежа:<br>
Функция `fst` - извелечение первого элемента
`snd` - извлечение второго элемента

2. Извлечение элементов из кортежа произвольной длины
Если за ключевым словом `let` указать несколько имен, разделенных запятыми, то с этими именами будут связаны значения элементов кортежа.
```fsharp
> let y = (1, 'd', 3.4);;
> let y1, y2, y3 = y;;
```

# Сопоставление с образцом

Конструкция **Сопоставления с образцом**: <br>
```fsharp
match выражение with
| образец_1 -> выражение_1
| образец_2 -> выражение_2
...
| образец_n -> выражение_n
```

> Все варианты должны возвращать значение одного типа

1. Образец - константа
```fsharp
let f i = 
    match i with
    |0 -> "Zero"
    |1 -> "One"
    |2 -> "Two"
    |_ -> "None"
```

2. Образец - переменная
```fsharp
let f i = 
    match i with
    |0 -> "Zero"
    |x -> x
```

3. Образец - кортеж
```fsharp
let f z = 
    match z with
    | (1.0, 2) -> "First"
    | (_, _) -> "Other"
```

4. Дополнительная проверка при сопоставлении с образцом
```fsharp
let rec luc x = 
    match x with
    | x when x <= -> -100
    | 1 -> 1
    | _ -> luc (x - 1) + luc (x - 2)
```

5. Объедение нескольких образцов 
```fsharp
let test c = 
    match c with
    | 'a' | 'b' | 'c' -> true
    | _ -> false
```

6. Образец может содержать 
```fsharp
let testand x y =
    match x, y with
    |1, _
    |_, 1 -> "одно из них равно 1"
    |x,y -> "другие"
```

7. Если набор вариантов не учитывает все возможные значения выражения, то компилятор выводит предупреждение
```fsharp
let f i =
    match i with
    | 1 -> "One"
```
`error`



## Пример. Рекурсия и сопоставление с образцом. Игра "Угадай число"

```fsharp
open System;
> let play_game () =
    let rng = new Random()
    let Number = rbg.Next() % 100
    let rec play_step () = 
        printfn "введи число"
        let Str = Console.ReadLine()
        let N = Convert.ToInt32(Str)
        match N with
            | _ when N > Number -> printfn "Загаданное число меньше"
                                   play_step()
            | _ when N = Number -> printft "Вы угадали!"
            | _ -> prinftn "Загаданное число больше"
                                   play_step()
    play_step()
printfn "Компьютер загадал число. Угадайте его"
play_game();;
```

