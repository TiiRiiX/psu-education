# Сравнить использование данных в императивных, функиональных и логических языках

Данные в императивных ЯП данные это переменные и константы. Переменные (ячейка памяти) - поименованное место памяти, куда можно записать значение. Переменные обладают значениями, которые могут изменяться инструкцией присваивания или вывода.

В функиональных языках переменные используются только для того, чтобы дать имена значениям аргументов функции и связать с этим постоянными значениями на протяжении всего вычисления выражения, определяющего результат функции.

В ФП проблема изменения значений переменных решается путем создания новых переменных.

В логических языках (на примере пролога) переменная используется для обозначения различных объектов, то есть не является именем конкретного объекта.

# C#. Сформулировать определения терминов: связывание, статическое связывание, динамическое связывание. Привести примеры программ, реализующих статическое и динамическое связывание.

**Связывание** - установление соответствия между вызовом метода и его реализацией

**Статическое связывание** - связывание во время компиляции

**Динамическое связывание** - связывание во время выполнения

```csharp
class A {
   public virtural void PrintToConsole() {
       Console.WriteLine("It's class A");
   }
}

class B : A {
   public override void PrintToConsole() {
       Console.WriteLine("It's class B");
   }
}

class Program {
   public static void Main() {
      A a = new B();
      a.PrintToConsole();
  }
}
```

# F#. Каррирование. Частично применимые функции. Пример рекурсивной каррированной функции.

**Каррирование** - это возможность функции принимать аргументы по одному, каждый раз возвращая новую функцию от меньшего числа аргументов.

Частично применимые функции дают возможность:

* **зафиксировать** значение **нескольких** аргументов функции
* **создать** новую функции **с меньшим** числом аргументов

```fsharp
> let rec mypow n x =
    if n = 0 then 1.0
        else x * mypow (n - 1) x;;
> let square = mypow 2;;
> let five = mypow 5;;        
```

# F#. Обосновать выбор структур данных в задаче "Анализ размерностей". Описать функцию вычисления размерности заданной величины.

Любую величину можно разложить по 3-м размерностям - масса, длинна, время, т.е. 
Мn1 Ln2 Tn3, следовательно проще всего будет предствавить размерность, как список -
`[n1;n2;n3]`

Тогда для простого обращения к размерностям, при составлении формул, их можно хранить в списке -
`[(v1, d1); (v2, d2), ... (vn,dn)] `
, где Vi - величина (символ), di - её размерность (список)

Само же выражение, например `V = U + a*t` мы представим в виде дерева


**аргумент функции `e`**: дерево выражения
**аргумент функции `a`**: список размерностей

```fsharp
let rec test e a =
    match e with
    | Value (x) -> dim x a
    | Op (op, L, R) ->
        match op with
        | 'x' | '-' -> eqdim (test L a) (test R a) //сравнивам размерност
        | '*' -> adddim (test L a) (test R a) //складываем размерности
        | '/' -> subdim (tset L a) (test R a) //вычитаем размерности
        | _ -> []
```

# Сравнить структуру программы в императивных и функиональных языках программирования.

# F#. Особенности областей действия имен. Привести пример и объяснить использование одинаковых имен значений во вложенных функциях.

**Тело функции может содержать определения индефикаторов** - локальных имен значений и функций.

1.  В  F# можно объъявить новую функцию в теле другой функции, т.е. функции могут быть вложенными
2. Область действия идентификатора - тело функции, в которой он объявлен
3. Вложенные функции имеет доступ к любым значениям, объявленным в объемлещюей функции.

*Именно отступ указывает на то, что определение идентификатора находится внутри тела функции*

Если встречается одинаковое имя во вложенной переменной и в объемлющей, то имя вложенной перекрывает объемлющую.

```fsharp
let test a =
    let fun a b =
        a - b
    fun 2 a
printfn test 1
```

# Обосновать наличие и взаимодействие лексического и синтаксического анализаторов в структуре компилятора. Привести пример.

Синтаксический анализатор делится на:

последовательность литер -> Лексический анализтора -> последовательность символов && лексические ошибки

последовательность символов -> Синтаксических анализатор -> синтаксически проверенная программа && синтаксические ошибки

*Лексический* анализатор (сканер) просматривает литеры исходной программы и
* строит символы (ликсемы) - идентификаторы, ключевые слова, разделители, числа
* распознает и *исключает комментарии*

*Синтаксический* анализатор проверяет, удволетворяет ли программа *формальным* правилам

# F#. Вычислить количество отрицательных элементов в дереве поиска.

```fsharp
type BinTree =
    | Node of int*BinTree*BinTree
    | Empty

let rec countNegative tree =
    match tree with
        | Node (data, left, right) when data < 0 -> 1 + (countNegative left) + (countNegative right)
        | Node (data, left, right) -> (countNegative left) + (countNegative right)
        | Empty -> 0
```

# F#. Вычислить количество операций умножения в дереве выражений.

```fsharp
type ExprTree =
    | Op of char*ExprTree*ExprTree
    | Value of int
    
let rec findOp tree =
    match tree with
        | Value (_) -> 0
        | Op (op, L, R) ->
            match op with
                | x when '*' = x -> 1 + (findOp L) + (findOp R)
                | _ -> (findOp L) + (findOp R)
```

# F#. Обосновать выбор структур данных в задаче "Анализ размерностей". Описать функцию для операций +, -, * и /. Каждая из этих функций имеет два аргумента - размерность и величина, а возвращает - результирующую размерность для соответствующей операции. Учесть возможность ошибочной ситуации.

Любую величину можно разложить по 3-м размерностям - масса, длинна, время, т.е. 
Мn1 Ln2 Tn3, следовательно проще всего будет предствавить размерность, как список -
`[n1;n2;n3]`

Тогда для простого обращения к размерностям, при составлении формул, их можно хранить в списке -
`[(v1, d1); (v2, d2), ... (vn,dn)] `
, где Vi - величина (символ), di - её размерность (список)

Само же выражение, например `V = U + a*t` мы представим в виде дерева

```fsharp
// + -
let eqdim l1 l2 =
    if l1 = l2 then l1
    else []
// *
let rec adddim l1 l2 =
    match l1, l2 with
    |[],_ -> []
    |_, [] -> []
    |h1::t1, h2::t2 -> (h1+h2)::adddim t1 t2
// /
let rec subdim l1 l2 =
    match l1, l2 with
    |[],_ -> []
    |_, [] -> []
    |h1::t1, h2::t2 -> (h1-h2)::subdim t1 t2
```

# Пролог. Обосновать использование динамической базы данных при создании экспертной системы. Описать утверждения, реализующей работу с динамической базой данных и диалог с пользователем (в рамках экспертной системы)

Мы используем ДБД в ЭС потому что только так мы можем динамически добавлять различные новые факты для достижения целей. При использовании СБД мы не сможем добавлять новые факты во время работы, и ЭС не будет в полной мере выполнять свои функции.

1. `asserta` - заносит новое утверждение в ДБД *перед всеми*
2. `assertz` - заносит новое утверждение в ДБД *после всех*
3. `retract` - удаляет утверждение из ДБД
4. `save` - сохраняет находящуюся в ОП ДБД в текстовом файле
5. `consult` - считывает в ОП файле ДБД