# Назначение переменных в прологе

Переменная Пролога используется для обозначения различных объектов (не является именем конкретного объекта)

Имя **переменное** должно начинаться с **прописной** буквы

Пример:

`знает (иван, X) :- знает (мария, X)`

`X` - переменная 

# Сопоставление фактов

Если имеет место какое-то отношение между объектами, то такой простейший вид утверждений называется **фактом**

Факт указывает на то, что выполнено некоторое **отношение** между объектами

Имена фактов и объектов должны начинаться **со строчных букв**

Факт: `знает (мария, английский)`

Одноместное отношение определяет **свойство объекта**

`студент(иванов)`

Когда пролог-система отвечает на вопросы, она ищет **факты** и **головы правил**, сопоставимые с целью.

**Два факта сопоставимы** (или соответствуют друг другу), если:

1. имена отношений одинаковы (побуквенное совпадение)
2. отношения имеют разное количество аргументов
3. аргументы, расположены в одинаковых позициях, сопоставимы
Сопоставление аргументов осуществляется по следующим правилам:
    1. имена конкретных объектов сопоставимы, если они совпадают
    2. переменная сопоставима с именем конкретного объекта
    3. переменная сопоставима с другой переменной

1. Сопоставляется
    * цель `знает (иван, английский)` и
    * факт `знает (мария, английский)`
    * Попытка сопоставить цель и факт **неуспешна** (первые аргументы несопоставимы)
2. Пролог продолжает поиск следующего предиката **знает** и находит правило:
    `знает (иван, X) :- знает (мария, X)`
    Цель и голова **сопоставимы** -> переменная X

# Схема логического вывода

![](./ЯП/схема.png)

# Назначение отсечения, правила отсечения и пример

Отсечение ограничивает поиск решений, запрещая поиск других решений для целей, которые были вычислены к моменту выполнения оператора отсечения. 
Проще говоря, он запрещает переход к другим правилам текущего предиката и откат внутри текущего правила к коду, расположенному до отсечения.

База знаний содержит утверждения:

```
H :- B1, B2, ..., Bm, !, Bm+1,..., Bn (1)
H :- ... (2)
```
и

Цель: G

В процессе доказательства

1. цель G сопоставляется с головой правила
2. доказываются подцели B1, ..., Bm
3. выполняется отсечение !
    1. результат выполнения отсечения:
        1. подцель B1, ..., Bm **не передоказываются** (замораживаются)
        2. цель G связывается только с правилом (1) и другие варианты доказательства G не рассматриваются

Пример. Нахождение наибольшего из двух чисел: 

БЗ:

```
max (X, Y, X) :- X >= Y
max (X, Y, Y)
```

Цель: `max (20, 15, X)`

Ответ: `X = 20, X = 15` **неверно**

Вариант2:

БЗ:

```
max (X, Y, X) :- X >= Y, !
max (X, Y, Y)
```

Цель: `max (20, 15, X)`

Ответ: `X = 20`

# Практика

## дана база знаний с населением и площадью стран. И надо выбрать большие страны(где население высокое т площадь )

```
население('Россия', 10).
население('США', 8).
население('Аргентина', 4).
население('Китай', 12).
население('Вах', 200).

площадь('Россия', 20).
площадь('Китай', 10).
площадь('Аргентина', 5).
площадь('США', 15).
площадь('Вах', 1).

это_максимальное_население(X) :- население(_, X1), X1 > X, !, fail.
это_максимальное_население(_).

это_максимальная_площадь(X) :- площадь(_, X1), X1 > X, !, fail.
это_максимальная_площадь(_).

максимальное_население(Страна, X) :- население(Страна, X), это_максимальное_население(X), !.
максимальная_площадь(Страна, X) :- площадь(Страна, X), это_максимальная_площадь(X), !.

большие_страны(Страна, Население, Площадь) :- максимальная_площадь(Страна, Площадь), максимальное_население(Страна, Население).
```

## Машины

```
машина('модель1', 'синий', 100).
машина('модель2', 'красный', 1000).
машина('модель3', 'синий', 500).

цвет('синий', 'темный').
цвет('красный', 'яркий').
```

Цель: `машина(X, Цвет, Цена), цвет(Цвет, 'темный'), Цена > 200.`

## Репка

```
тянет('кошка','мышка').
тянет('жучка','кошка').
тянет('внучка','жучка').
тянет('бабка','внучка').
тянет('дед','бабка').
тянет('репка','дед').

через(X,Y) :-тянет(Z,Y), тянет(X,Z).
последний(Z) :- тянет(_,Z),not(тянет(Z,_)).
между(X,Y,Z) :- тянет(X,Y), тянет(Y,Z).
```

## Не нулевые элементы

```
не_нулевые([], 0) :-!.
не_нулевые([0 | Tail], N) :- не_нулевые(Tail, N1), N is N1 + 1.
не_нулевые([_ | Tail], N) :- не_нулевые(Tail, N).
```